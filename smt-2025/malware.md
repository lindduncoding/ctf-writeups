## Malware CTF Challenges

Part of SMTP 2025

Written by fredora

## Static

Description

```
Before you start analyzing a malware file, it is generally a good practice to take its hash and search it on VirusTotal to see if others have analyzed the same file before. For this challenge, we give you this SHA256 hash: `556700ac50ffa845e5de853498242ee5abb288eb5b8ae1ae12bfdb5746e3b7b1`.

Answer the questions at `nc 52.77.77.117 10031`
```

This is an easy/baby challenge to introduce you about how to use VirusTotal as a first stop for malware analysis. Visiting VirusTotal to look for the hash of the file will return the ILOVEYOU worm report.

Connecting to the IP address, you will be facing a usual forensics type of challenge where you need to answer multiple questions to get the flag.

```
fred@fedora:~$ nc 52.77.77.117 10031
===================
  static analysis  
===================

1. What type of malware is it mainly attributed as? (e.g. trojan)
>>> worm
Correct! Next...

2. What is the file type of the malware? (e.g. apk)
>>> vba
Correct! Next...

3. When is the first time the malware was submitted to VirusTotal? (e.g. 2020-12-31)
>>> 2016-06-11
Correct! Next...

4. According to the "behavior" section, the malware was executed using a Windows executable. What is the name of the executable? (e.g. powershell.exe)
>>> wscript.exe
Correct! Next...

Congrats! 4 out of 4 answers correct!

Flag: SMT2025{us3_v1rus_t0t4l_4_1niti4l_4nalys1s}
```

## Macro 1

Description

```
Why does the file extension ends in `m`? I thought it's supposed to be `xlsx`?

ZIP file password: SMT2025
```

The ZIP file contains an Excel file that has Macro embedded in it. You don't need Microsoft Office to open the file or the macro. This is me showing the macro file to analyze using LibreOffice:

![macro](/smt-2025/images/macro.png)

Going through the macro will return this flag:

```
Rem Attribute VBA_ModuleType=VBADocumentModule
Option VBASupport 1
Private Sub Workbook_Open()
    Dim secretMessage As String
    secretMessage = "SMT2025{m4cr0s_4r3_c00l}"
    MsgBox "You've been hacked"
End Sub
```

You can also use olevba to analyze the macro.

## Macro 2

Description

```
Okay, the last macro was nothing. This time, I've devised a more complex one! Only the computer can understand it!

ZIP file password: SMT2025
```

We are given another Excel file with macros embedded as well. However, this time the macro file is more complicated and requires simple reverse engineering. The interesting macro looks like this:

```
Rem Attribute VBA_ModuleType=VBADocumentModule
Option VBASupport 1
Private Declare PtrSafe Function CreateThread Lib "kernel32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib "kernel32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "kernel32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr
Private Declare PtrSafe Function WaitForSingleObject Lib "kernel32" (ByVal hHandle As LongPtr, ByVal dwMilliseconds As Long) As Long
Private Declare PtrSafe Function GetExitCodeThread Lib "kernel32" (ByVal hThread As LongPtr, lpExitCode As Long) As Long

Sub FlagChecker()
    Dim shellcode As Variant
    Dim userInput As String
    Dim addrShellcode As LongPtr
    Dim addrInput As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As Long
    Dim ThreadId As Long
    Dim hThread As LongPtr
    Dim exitCode As Long

    shellcode = Array(49, 192, 128, 57, 83, 117, 110, 128, 121, 1, 77, 117, 104, 128, 121, 2, 84, 117, 98, 128, 121, 3, 50, 117, 92, 128, 121, 4, 48, 117, 86, 128, 121, 5, 50, 117, 80, 128, 121, 6, 53, 117, 74, 128, 121, 7, 123, 117, 68, 128, 121, 8, 121, 117, 62, 128, 121, 9, 48, 117, 56, 128, 121, 10, 117, 117, 50, 128, 121, 11, 95, 117, 44, 128, 121, 12, 103, 117, 38, 128, 121, 13, 48, 117, 32, 128, 121, 14, 116, 117, 26, 128, 121, 15, 95, 117, 20, 128, 121, 16, 109, 117, 14, 128, 121, 17, 51, 117, 8, 128, 121, 18, 125, 117, 2, 176, 1, 195)

    userInput = InputBox("Welcome! To access the secret, you must enter the flag:", "Flag Check")

    addrShellcode = VirtualAlloc(0, UBound(shellcode) + 1, &H3000, &H40)

    For counter = LBound(shellcode) To UBound(shellcode)
        data = shellcode(counter)
        RtlMoveMemory ByVal (addrShellcode + counter), data, 1
    Next counter

    addrInput = VirtualAlloc(0, 19, &H3000, &H40)

    For counter = 0 To Len(userInput) - 1
        data = Asc(Mid(userInput, counter + 1, 1))
        RtlMoveMemory ByVal (addrInput + counter), data, 1
    Next counter

    hThread = CreateThread(0, 0, addrShellcode, addrInput, 0, ThreadId)

    WaitForSingleObject hThread, &HFFFFFFFF

    GetExitCodeThread hThread, exitCode

    If exitCode = 1 Then
        MsgBox "Correct Flag!", vbInformation
    Else
        MsgBox "Incorrect Flag!", vbExclamation
    End If
End Sub

Private Sub Workbook_Open()
    FlagChecker
End Sub
```

Even without prior knowledge of macro scripting, it's clear that the macro is asking for a flag item to be compared using the hardcoded shellcode. Shellcodes are just raw bytes representation of assembly instructions. So, to know how the flag comparison works, we need to decode the shellcode array into its appropriate assembly representation. Using this python script to make a bin file of the shellcode:

```
bytes_array = [
    49, 192, 128, 57, 83, 117, 110, 128, 121, 1, 77, 117, 104, 128, 121, 2, 84, 117, 98, 128, 121, 3, 50, 117, 92, 128, 121, 4, 48, 117, 86, 128, 121, 5, 50, 117, 80, 128, 121, 6, 53, 117, 74, 128, 121, 7, 123, 117, 68, 128, 121, 8, 121, 117, 62, 128, 121, 9, 48, 117, 56, 128, 121, 10, 117, 117, 50, 128, 121, 11, 95, 117, 44, 128, 121, 12, 103, 117, 38, 128, 121, 13, 48, 117, 32, 128, 121, 14, 116, 117, 26, 128, 121, 15, 95, 117, 20, 128, 121, 16, 109, 117, 14, 128, 121, 17, 51, 117, 8, 128, 121, 18, 125, 117, 2, 176, 1, 195
]


with open("shellcode.bin", "wb") as f:
    f.write(bytes(bytes_array))
```

And using `ndisasm` to disassemble the binary will return:

```
00000000  31C0              xor eax,eax
00000002  803953            cmp byte [ecx],0x53
00000005  756E              jnz 0x75
00000007  8079014D          cmp byte [ecx+0x1],0x4d
0000000B  7568              jnz 0x75
0000000D  80790254          cmp byte [ecx+0x2],0x54
00000011  7562              jnz 0x75
00000013  80790332          cmp byte [ecx+0x3],0x32
00000017  755C              jnz 0x75
00000019  80790430          cmp byte [ecx+0x4],0x30
0000001D  7556              jnz 0x75
0000001F  80790532          cmp byte [ecx+0x5],0x32
00000023  7550              jnz 0x75
00000025  80790635          cmp byte [ecx+0x6],0x35
00000029  754A              jnz 0x75
0000002B  8079077B          cmp byte [ecx+0x7],0x7b
0000002F  7544              jnz 0x75
00000031  80790879          cmp byte [ecx+0x8],0x79
00000035  753E              jnz 0x75
00000037  80790930          cmp byte [ecx+0x9],0x30
0000003B  7538              jnz 0x75
0000003D  80790A75          cmp byte [ecx+0xa],0x75
00000041  7532              jnz 0x75
00000043  80790B5F          cmp byte [ecx+0xb],0x5f
00000047  752C              jnz 0x75
00000049  80790C67          cmp byte [ecx+0xc],0x67
0000004D  7526              jnz 0x75
0000004F  80790D30          cmp byte [ecx+0xd],0x30
00000053  7520              jnz 0x75
00000055  80790E74          cmp byte [ecx+0xe],0x74
00000059  751A              jnz 0x75
0000005B  80790F5F          cmp byte [ecx+0xf],0x5f
0000005F  7514              jnz 0x75
00000061  8079106D          cmp byte [ecx+0x10],0x6d
00000065  750E              jnz 0x75
00000067  80791133          cmp byte [ecx+0x11],0x33
0000006B  7508              jnz 0x75
0000006D  8079127D          cmp byte [ecx+0x12],0x7d
00000071  7502              jnz 0x75
00000073  B001              mov al,0x1
00000075  C3                ret
```

The assembly uses a lot of `compare` instructions to compare the input from the user with the actual flag. Decoding the bytes that is used to compare the input will return the flag:

```
SMT2025{y0u_g0t_m3}
```

## Strange PDF

Description

```
I visited a URL to get free ROBUX, but it gave me a PDF instead? Now I'm afraid because when I open the PDF on a browser, it says ""You are hacked!"".

Note: the PDF file is harmless and safe to open.
```

Was given a pcap file where I could extract a suspicious pdf:

![pdf](/smt-2025/images/export-pdf.png)

The challenge description (and hint) hinted that the pdf file contain a Javascript code. Running it on a browser (not recommended) will give you the alert "you are hacked", just like what's said in the description. Using a safer and more effective tool like pdf-parser, we can detect the Javascript object:

```
fred@fedora:~$ pdf-parser --search  freeR0buxx.pdf 
This program has not been tested with this version of Python (3.13.3)
Should you encounter problems, please use Python version 3.12.2
obj 1 0
 Type: /Catalog
 Referencing: 3 0 R, 3 0 R, 4 0 R, 5 0 R

  <<
    /Lang (en_GB)
    /MarkInfo
      <<
        /Marked true
        /Type /MarkInfo
      >>
    /Names
      <<
        /JavaScript
          <<
            /Names
              <<
                /JS 3 0 R
                /S /JavaScript
              >>
            ]
          >>
      >>
    /OpenAction
      <<
        /JS 3 0 R
        /S /JavaScript
      >>
    /Pages 4 0 R
    /StructTreeRoot 5 0 R
    /Type /Catalog
    /ViewerPreferences
      <<
        /DisplayDocTitle true
        /Type /ViewerPreferences
      >>
  >>
```

There is one Javascript object (JS 3 0 R) that can be analyzed further with:

```
fred@fedora:~$ pdf-parser freeR0buxx.pdf --object 3 --raw
This program has not been tested with this version of Python (3.13.3)
Should you encounter problems, please use Python version 3.12.2
obj 3 0
 Type: 
 Referencing: 
 Contains stream

  <<
    /Length 715
    /Filter /FlateDecode
  >>
```

Seems like the object is filtered/decoded or not in a raw form. So, let's use the --filter option to analyze it even further:

```
 b"const _0x35af3f=_0x38dc;(function(_0x79f814,_0x52d802){const _0x107e33=_0x38dc,_0x40247f=_0x79f814();while(!![]){try{const _0x2c9e4e=-parseInt(_0x107e33(0x1e4))/0x1*(parseInt(_0x107e33(0x1ed))/0x2)+parseInt(_0x107e33(0x1ec))/0x3+parseInt(_0x107e33(0x1eb))/0x4+-parseInt(_0x107e33(0x1f0))/0x5*(parseInt(_0x107e33(0x1e6))/0x6)+-parseInt(_0x107e33(0x1ee))/0x7*(parseInt(_0x107e33(0x1e3))/0x8)+-parseInt(_0x107e33(0x1ef))/0x9*(-parseInt(_0x107e33(0x1ea))/0xa)+-parseInt(_0x107e33(0x1e9))/0xb;if(_0x2c9e4e===_0x52d802)break;else _0x40247f['push'](_0x40247f['shift']());}catch(_0x53d799){_0x40247f['push'](_0x40247f['shift']());}}}(_0x425d,0x282ee),app[_0x35af3f(0x1e5)](_0x35af3f(0x1e2)));const secretCodes=[0x53,0x4c,0x56,0x31,0x34,0x37,0x33,0x7c,0x7a,0x39,0x68,0x7e,0x74,0x52,0x69,0x3f,0x7e,0x22,0x4d,0x61,0x24,0x77,0x7a,0x27,0x60,0x46,0x2e,0x78,0x7f,0x2d,0x6b,0x71,0x54,0x7e,0x16,0x4f,0x11,0x4a,0x79,0x40,0x18,0x47,0x19,0x56];let res_string='';function _0x425d(){const _0x5e00bb=['98WMXaGj','14hdAIoV','63vplRra','7475BnkArh','you are hacked lol','15352DpCPAf','5671bukCjs','alert','414tTEYYo','fromCharCode','length','2470809jgIBmC','274390qpkmeC','1097232WLgqcA','923100FinnSJ'];_0x425d=function(){return _0x5e00bb;};return _0x425d();}function _0x38dc(_0x4b04be,_0x45a38d){const _0x425d36=_0x425d();return _0x38dc=function(_0x38dcc5,_0x16d34d){_0x38dcc5=_0x38dcc5-0x1e2;let _0x29ff77=_0x425d36[_0x38dcc5];return _0x29ff77;},_0x38dc(_0x4b04be,_0x45a38d);}for(let i=0x0;i<secretCodes[_0x35af3f(0x1e8)];i++){const xored=secretCodes[i]^i,res_char=String[_0x35af3f(0x1e7)](xored);res_string+=res_char;}"
```

This is definitely an obfuscated Javascript code, using online JS de-obfuscater will return this code:

```
const secretCodes = [0x53, 0x4c, 0x56, 0x31, 0x34, 0x37, 0x33, 0x7c, 0x7a, 0x39, 0x68, 0x7e, 0x74, 0x52, 0x69, 0x3f, 0x7e, 0x22, 0x4d, 0x61, 0x24, 0x77, 0x7a, 0x27, 0x60, 0x46, 0x2e, 0x78, 0x7f, 0x2d, 0x6b, 0x71, 0x54, 0x7e, 0x16, 0x4f, 0x11, 0x4a, 0x79, 0x40, 0x18, 0x47, 0x19, 0x56];
let res_string = '';
for (let i = 0x0; i < secretCodes.length; i++) {
  const xored = secretCodes[i] ^ i;
  const res_char = String.fromCharCode(xored);
  res_string += res_char;
}
```

The code turns out to be a mechanism to reveal the secret code (possibly the flag) by using XOR mechanism. I added the console.log() part to print the XOR-ed secret code and running the de-obfuscated code will return the flag:

```
fred@fedora:~/Documents/SMT $ node test.js
SMT2025{r0bux_g0n3_r0bl0x_4cc0unt_4l5o_g0n3}
```